var search_data = {"index":{"searchIndex":["clienttests","freenet","fcp","client","fcpconnectionerror","message","requestfailed","requestfinished","site","siteerror","uri","urierror","urimethodnotimplementederror","freenetpage","freenetpageerror","getoptlong","indexr","messagetests","object","queueserver","queueweb","rdoc","uritest","<=>()","<=>()","add_site()","add_uris()","all_messages()","callback?()","categorize()","connect()","connect()","continue_thread()","create_index_page()","data_for()","details_for()","disconnect()","disconnect()","do_get()","do_post()","generate_key()","generate_keypair()","get()","insert_file()","insert_site()","list_persistent_requests()","load_request()","load_sites()","merge()","mine_page()","modify_request()","name=()","new()","new()","new()","new()","new()","new()","new()","new()","new()","next_version()","path=()","process_message()","process_page()","process_site()","put()","put_complex_dir()","putdir()","read()","remove()","remove_request()","request_status()","root?()","run_rank()","save_sites()","site()","site=()","start_server()","start_server()","status()","status()","test_callback()","test_chk_parsing()","test_ksk_parsing()","test_part_merge()","test_path_merge()","test_ssk_parsing()","test_ssk_version_parsing()","test_usk_parsing()","test_write_data()","test_write_message()","to_hash()","unknown_message()","version=()","wait_for_response()","watch_global()","write()","readme","rakefile","readme","index.rhtml","readme","index.rhtml","readme"],"longSearchIndex":["clienttests","freenet","freenet::fcp","freenet::fcp::client","freenet::fcp::fcpconnectionerror","freenet::fcp::message","freenet::fcp::requestfailed","freenet::fcp::requestfinished","freenet::site","freenet::siteerror","freenet::uri","freenet::urierror","freenet::urimethodnotimplementederror","freenetpage","freenetpageerror","getoptlong","indexr","messagetests","object","queueserver","queueweb","rdoc","uritest","freenet::uri#<=>()","freenetpage#<=>()","freenet::site::add_site()","queueserver#add_uris()","freenet::fcp::client#all_messages()","freenet::fcp::message#callback?()","freenetpage#categorize()","freenet::fcp::client#connect()","freenet::site#connect()","freenet::fcp::message#continue_thread()","indexr#create_index_page()","queueserver#data_for()","queueserver#details_for()","freenet::fcp::client#disconnect()","freenet::site#disconnect()","queueweb#do_get()","queueweb#do_post()","freenet::site#generate_key()","freenet::fcp::client#generate_keypair()","freenet::fcp::client#get()","freenet::site#insert_file()","freenet::site#insert_site()","freenet::fcp::client#list_persistent_requests()","freenet::fcp::client#load_request()","freenet::site::load_sites()","freenet::uri#merge()","indexr#mine_page()","freenet::fcp::client#modify_request()","freenet::uri#name=()","freenet::fcp::client::new()","freenet::fcp::message::new()","freenet::fcp::requestfailed::new()","freenet::site::new()","freenet::uri::new()","freenetpage::new()","indexr::new()","queueserver::new()","queueweb::new()","freenet::uri#next_version()","freenet::uri#path=()","queueserver#process_message()","indexr#process_page()","freenet::site#process_site()","freenet::fcp::client#put()","freenet::fcp::client#put_complex_dir()","freenet::fcp::client#putdir()","freenet::fcp::message::read()","queueserver#remove()","freenet::fcp::client#remove_request()","freenet::fcp::client#request_status()","freenet::uri#root?()","freenetpage#run_rank()","freenet::site::save_sites()","freenet::uri#site()","freenet::uri#site=()","queueserver::start_server()","queueweb::start_server()","freenet::fcp::message#status()","queueserver#status()","clienttests#test_callback()","uritest#test_chk_parsing()","uritest#test_ksk_parsing()","uritest#test_part_merge()","uritest#test_path_merge()","uritest#test_ssk_parsing()","uritest#test_ssk_version_parsing()","uritest#test_usk_parsing()","messagetests#test_write_data()","messagetests#test_write_message()","freenet::site#to_hash()","freenet::fcp::client#unknown_message()","freenet::uri#version=()","freenet::fcp::message#wait_for_response()","freenet::fcp::client#watch_global()","freenet::fcp::message#write()","","","","","","",""],"info":[["ClientTests","","ClientTests.html","",""],["Freenet","","Freenet.html","",""],["Freenet::FCP","","Freenet/FCP.html","",""],["Freenet::FCP::Client","","Freenet/FCP/Client.html","","<p>Implements Freenet Client Protocol client in Ruby. It is multithreaded and\nmostly thread-safe.\n<p>Bugs\n<p>Probably …\n"],["Freenet::FCP::FCPConnectionError","","Freenet/FCP/FCPConnectionError.html","","<p>Raised if an FCP connection can&#39;t be made or if the connection dies.\n"],["Freenet::FCP::Message","","Freenet/FCP/Message.html","","<p>An FCP::Message represents a communication between the server and client.\nIt handles basic information …\n"],["Freenet::FCP::RequestFailed","","Freenet/FCP/RequestFailed.html","","<p>Raised if a synchronous request fails\n"],["Freenet::FCP::RequestFinished","","Freenet/FCP/RequestFinished.html","","<p>If raised by a callback the entry is removed from the message list and the\nidentifier can be reused properly …\n"],["Freenet::Site","","Freenet/Site.html","",""],["Freenet::SiteError","","Freenet/SiteError.html","",""],["Freenet::URI","","Freenet/URI.html","","<p>Represents a Freenet URI. Provides manipulation with awareness of the\nFreenet structure, such as USK …\n"],["Freenet::URIError","","Freenet/URIError.html","","<p>Raised if a URI can&#39;t be parsed or handled for some reason\n"],["Freenet::URIMethodNotImplementedError","","Freenet/URIMethodNotImplementedError.html","","<p>Raised if a feature isn&#39;t implemented by a URI, eg versioning for CHKs\n"],["FreenetPage","","FreenetPage.html","","<p>A page on Freenet, uses beautifulsoup to parse non-XML-compliant HTML\nfiles,\n"],["FreenetPageError","","FreenetPageError.html","","<p>Generic FreenetPageError\n"],["GetoptLong","","GetoptLong.html","",""],["IndexR","","IndexR.html","","<p>Example for FreenetR useage.\n<p>This is a very simple freenet spider. It starts at a URI, follows all HTML\n…\n"],["MessageTests","","MessageTests.html","",""],["Object","","Object.html","",""],["QueueServer","","QueueServer.html","","<p>DRuby server\n"],["QueueWeb","","QueueWeb.html","",""],["RDoc","","RDoc.html","",""],["URITest","","URITest.html","",""],["<=>","Freenet::URI","Freenet/URI.html#method-i-3C-3D-3E","(other)",""],["<=>","FreenetPage","FreenetPage.html#method-i-3C-3D-3E","(other)",""],["add_site","Freenet::Site","Freenet/Site.html#method-c-add_site","(site)",""],["add_uris","QueueServer","QueueServer.html#method-i-add_uris","(*args)","<p>Add URIs to the queue. Takes a variable argument list, each argument should\nbe one URI. Returns the list …\n"],["all_messages","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-all_messages","(&callback)",""],["callback?","Freenet::FCP::Message","Freenet/FCP/Message.html#method-i-callback-3F","()",""],["categorize","FreenetPage","FreenetPage.html#method-i-categorize","()","<p>Magic voodoo of half-baked ideas. It&#39;s supposed to sort pages in to\ncategories.\n"],["connect","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-connect","()","<p>Performs the connection and worker thread creation\n<p>raises FCPConnectionError if something goes wrong\n"],["connect","Freenet::Site","Freenet/Site.html#method-i-connect","()",""],["continue_thread","Freenet::FCP::Message","Freenet/FCP/Message.html#method-i-continue_thread","(message)","<p>Sets the reply. This is private to FCP::Client\n"],["create_index_page","IndexR","IndexR.html#method-i-create_index_page","()","<p>Create index page. Sort pages and send to the erb template\n"],["data_for","QueueServer","QueueServer.html#method-i-data_for","(uri)",""],["details_for","QueueServer","QueueServer.html#method-i-details_for","(uri)",""],["disconnect","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-disconnect","()","<p>Get the worker thread to disconnect. Doesn&#39;t guarantee immediate\ndisconnection as any message currently …\n"],["disconnect","Freenet::Site","Freenet/Site.html#method-i-disconnect","()",""],["do_GET","QueueWeb","QueueWeb.html#method-i-do_GET","(req, res)",""],["do_POST","QueueWeb","QueueWeb.html#method-i-do_POST","(req, res)",""],["generate_key","Freenet::Site","Freenet/Site.html#method-i-generate_key","()",""],["generate_keypair","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-generate_keypair","(block = true, &callback)","<p>Generates a keypair for SSK use. If used synchronously it returns\n[InsertURI, RequestURI], otherwise …\n"],["get","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-get","(uri, block=true, options=nil, &callback)","<p>Request a file from Freenet.\n<p>Applicable status messages:\n<p>:pending &mdash; The message is in Freenet&#39;s queue. …\n"],["insert_file","Freenet::Site","Freenet/Site.html#method-i-insert_file","(path, type = nil, site=nil)","<p>Insert a single file. You probably want a CHK for this, use it to insert\nlarge files that won&#39;t change, …\n"],["insert_site","Freenet::Site","Freenet/Site.html#method-i-insert_site","(path = nil)","<p>Insert a whole site from disk\n"],["list_persistent_requests","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-list_persistent_requests","()",""],["load_request","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-load_request","(message)","<p>Loads a request in to the queue. This is for persistent requests, read the\nnotes above for more details …\n"],["load_sites","Freenet::Site","Freenet/Site.html#method-c-load_sites","()",""],["merge","Freenet::URI","Freenet/URI.html#method-i-merge","(uri)","<p>Merge in a URI or a URI fragment and provide the finished URI. Attempts to\ndo what a browser would\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">uri</span>.<span class=\"ruby-identifier\">merge</span>(<span class=\"ruby-string\">&quot;image.jpg&quot;</span>)\n</pre>\n"],["mine_page","IndexR","IndexR.html#method-i-mine_page","(uri, depth=0)","<p>Mine a page. uri is a Freenet::URI. depth is managed by mine_page to ensure\nthat we don&#39;t exceed …\n"],["modify_request","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-modify_request","(message, options)","<p>Modify a persistent request. Pass the options to change, though Identifier\nand Global must remain the …\n"],["name=","Freenet::URI","Freenet/URI.html#method-i-name-3D","(name)",""],["new","Freenet::FCP::Client","Freenet/FCP/Client.html#method-c-new","(client_name=nil, server=\"127.0.0.1\", port=9481, options={})","<p>Constructor, prepares various settings and connects to the Freenet node\n<p>client_name &mdash; A unique identifier …\n"],["new","Freenet::FCP::Message","Freenet/FCP/Message.html#method-c-new","(type, data = nil, items = [], callback = nil)","<p>type &mdash; The FCP message type\n<p>data &mdash; Any data to send with the message\n<p>items &mdash; A hash of message parameters. They …\n"],["new","Freenet::FCP::RequestFailed","Freenet/FCP/RequestFailed.html#method-c-new","(original_message)",""],["new","Freenet::Site","Freenet/Site.html#method-c-new","(type, path, name)",""],["new","Freenet::URI","Freenet/URI.html#method-c-new","(uri = nil)","<p>This can take a URI in following formats:\n\n<pre>/freenet:SSK@...\nSSK@...</pre>\n<p>Currently supports SSK, USK, KSK and …\n"],["new","FreenetPage","FreenetPage.html#method-c-new","(url, data)",""],["new","IndexR","IndexR.html#method-c-new","()","<p>Start spidering\n"],["new","QueueServer","QueueServer.html#method-c-new","()",""],["new","QueueWeb","QueueWeb.html#method-c-new","(server)",""],["next_version","Freenet::URI","Freenet/URI.html#method-i-next_version","()",""],["path=","Freenet::URI","Freenet/URI.html#method-i-path-3D","(path)",""],["process_message","QueueServer","QueueServer.html#method-i-process_message","(status, request, response)",""],["process_page","IndexR","IndexR.html#method-i-process_page","(uri, page, depth)","<p>Pull links out of a page and mine them deeper\n"],["process_site","Freenet::Site","Freenet/Site.html#method-i-process_site","()",""],["put","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-put","(uri, data=nil, block=true, options=nil, &callback)","<p>Put data in to freenet\n<p>This is a very simple put, if you wish to insert a directory then use\nClient#put_dir …\n"],["put_complex_dir","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-put_complex_dir","(uri, details, block, options, &callback)","<p>Put a &#39;complex&#39; dir\n"],["putdir","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-putdir","(uri, dir, block=true, options=nil, &callback)","<p>Upload a directory to a key, either SSK or USK. This directory must be\nlocal to the node we&#39;re connecting …\n"],["read","Freenet::FCP::Message","Freenet/FCP/Message.html#method-c-read","(stream)","<p>Read from stream and create a new message object\n"],["remove","QueueServer","QueueServer.html#method-i-remove","(uri)","<p>Remove the URI from the queue.\n"],["remove_request","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-remove_request","(message)","<p>Remove a persistent request from the node. Call this once you&#39;ve\nfinished with a request.\n"],["request_status","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-request_status","(identifier, global, only_data=true, block=true, &callback)","<p>Get the request status for a persistent request. Not useful in synchronous\nsystems. This will output …\n"],["root?","Freenet::URI","Freenet/URI.html#method-i-root-3F","()","<p>Returns true if we&#39;re at the &#39;base&#39; page of a URI using the\nfollowing:\n<p>KSKs and CHKs only …\n"],["run_rank","FreenetPage","FreenetPage.html#method-i-run_rank","(rank, all_pages)",""],["save_sites","Freenet::Site","Freenet/Site.html#method-c-save_sites","(sites)",""],["site","Freenet::URI","Freenet/URI.html#method-i-site","()",""],["site=","Freenet::URI","Freenet/URI.html#method-i-site-3D","(site)",""],["start_server","QueueServer","QueueServer.html#method-c-start_server","(bind_to)",""],["start_server","QueueWeb","QueueWeb.html#method-c-start_server","(port)",""],["status","Freenet::FCP::Message","Freenet/FCP/Message.html#method-i-status","()","<p>Gets the status for this message. The key ones all apps need to handle are:\n<p>:finished &mdash; When a request has …\n"],["status","QueueServer","QueueServer.html#method-i-status","()","<p>Get a list of all URIs and their status, a hash in the format:\n\n<pre>uri =&gt; {:status=&gt;(:started, &#39;Failed&#39;, &#39;Data ...</pre>\n"],["test_callback","ClientTests","ClientTests.html#method-i-test_callback","()",""],["test_chk_parsing","URITest","URITest.html#method-i-test_chk_parsing","()",""],["test_ksk_parsing","URITest","URITest.html#method-i-test_ksk_parsing","()","<p>def teardown end\n"],["test_part_merge","URITest","URITest.html#method-i-test_part_merge","()",""],["test_path_merge","URITest","URITest.html#method-i-test_path_merge","()",""],["test_ssk_parsing","URITest","URITest.html#method-i-test_ssk_parsing","()",""],["test_ssk_version_parsing","URITest","URITest.html#method-i-test_ssk_version_parsing","()",""],["test_usk_parsing","URITest","URITest.html#method-i-test_usk_parsing","()",""],["test_write_data","MessageTests","MessageTests.html#method-i-test_write_data","()","<p>Check that a message writes data properly\n"],["test_write_message","MessageTests","MessageTests.html#method-i-test_write_message","()","<p>Check that a message is written in the correct format with an identifier\n"],["to_hash","Freenet::Site","Freenet/Site.html#method-i-to_hash","()",""],["unknown_message","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-unknown_message","(&callback)",""],["version=","Freenet::URI","Freenet/URI.html#method-i-version-3D","(version)",""],["wait_for_response","Freenet::FCP::Message","Freenet/FCP/Message.html#method-i-wait_for_response","()","<p>Used to block until the reply is received for synchronous messages. May be\ncalled from any thread.\n"],["watch_global","Freenet::FCP::Client","Freenet/FCP/Client.html#method-i-watch_global","(enabled=true, verbosity=1)","<p>Enable global queue watching. This isn&#39;t of much use until I implement\na global callback for unknown …\n"],["write","Freenet::FCP::Message","Freenet/FCP/Message.html#method-i-write","(stream)","<p>Write this object to an FCP stream.\n"],["README","","README.html","","<p>rubyFreenet: An FCP implementation in Ruby\n<p>See freenet/doc/index.html for usage information.\n"],["Rakefile","","Rakefile.html","","<p>require &#39;./freenet&#39; task :test do\n\n<pre>require &#39;test/unit&#39;\nrequire &#39;freenet/tests/uri_tests&#39;\nrequire ...</pre>\n"],["README","","indexr/README.html","","<p>Indexr is a basic freenet spider. It starts off at the darknet index and\ndescends in to pages from there. …\n"],["index.rhtml","","indexr/index_rhtml.html","","<p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.1//EN”\n\n<pre>&quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</pre>\n"],["README","","rqueue/README.html","","<p>Freenet Queue Downloader =\n<p>Simply run ./rqueue\n<p>All requests are stored in the global queue, all completed …\n"],["index.rhtml","","rqueue/templates/index_rhtml.html","","<p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.1//EN”\n\n<pre>&quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</pre>\n"],["README","","rsite/README.html","","<p>rsite is a Freenet site management utility currently in development.\n<p>More documentation is forthcoming. …\n"]]}}